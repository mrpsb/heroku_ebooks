import random
import re
import sys
import twitter
import markov
import pyttsx
import cPickle as pickle

from htmlentitydefs import name2codepoint as n2c
from local_settings import *
from sense_hat import SenseHat

# Edited for running direct on Ras Pi using cron
# Instead of giving up on a failed tweet retries until success
# Altered to bring in pre-prepared brain from disk

def connect():
    api = twitter.Api(consumer_key=MY_CONSUMER_KEY,
                          consumer_secret=MY_CONSUMER_SECRET,
                          access_token_key=MY_ACCESS_TOKEN_KEY,
                          access_token_secret=MY_ACCESS_TOKEN_SECRET)
    return api

if __name__=="__main__":

    hat = SenseHat()
    
    if DEBUG==False:
        guess = random.choice(range(ODDS))
    else:
        guess = 0

    if guess == 0:
        if DEBUG == False:
            api = connect()
                           
        success = False

        # Read back brain generated by ingest.py
        mine = pickle.load(open( BRAIN_LOCATION + "botbrain.p" , "rb" ))
        source_tweets = pickle.load(open( BRAIN_LOCATION + "source_tweets.p" , "rb" ))
        
        # this section does the actual building of tweet
        # changed it to try again on failure, default was to just give up

        while success == False:
            
            ebook_tweet = ""  # this clears out any previous unsuccessful attempt
            
            ebook_tweet = mine.generate_sentence()
   
            #if a tweet is very short, this will randomly add a second sentence to it.
            if ebook_tweet != None and len(ebook_tweet) < 40:
                  print "Short tweet. Adding another sentence randomly"
                  newer_tweet = mine.generate_sentence()
                  if newer_tweet != None:
                      ebook_tweet += " " + mine.generate_sentence()
                  else:
                      ebook_tweet = ebook_tweet

            #throw out tweets that match anything from the source account.
            if ebook_tweet != None and len(ebook_tweet) < 120:
                success = True
                for tweet in source_tweets:
                    if ebook_tweet[:-1] not in tweet:
                        continue
                    else: 
                        print "TOO SIMILAR: " + ebook_tweet
                        success = False
            elif ebook_tweet == None:
                print "I done goofed, there's nothing in the tweet"
                success = False
            elif len(ebook_tweet) >= 120:
                print "That's too long, whoopsypoops"
                success = False
            else:
                print "I have no idea what I'm doing"
                success = False
            
        # Couldn't find anything wrong with the tweet so here goes
            if success == True:
                if DEBUG == False:
                    status = api.PostUpdate(ebook_tweet)
                    s = status.text.encode('utf-8')
	            print s
                    spk = pyttsx.init()
                    spk.setProperty('rate',100)
		    spk.setProperty('voice','english_rp')
	            spk.say(s)
                    spk.runAndWait()
                    hat.show_message(s)		
                else:
                    print "SUCCESS: " + ebook_tweet
                
    else:
        print "This time I'm not doing a tweet, so there" #message if the random number fails.
